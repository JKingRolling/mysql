# mysql基础知识

## 1. mysql主键

主键:primary key,表中主要的键，每张表中只能有一个字段使用此属性

主要作用：用来唯一的约束该字段里面的数据，不能重复

主键约束：即主键对应的字段里面的数据不允许重复，如果重复，则数据操作（增改）失败

主键分类：根据主键的字段类型，咱们可以将主键分为两类：

- 业务主键，使用真实的业务数据作为主键，例如学号、课程编号等等
- 逻辑主键，使用逻辑性的字段作为主键，字段没有业务含义，值有没有都没有关系，经常使用

## 2. mysql唯一键

唯一键：每张表中往往有多个字段需要具有唯一性，数据不能重复，但是在每张表中，只能有一个主键，因此唯一键用来解决表中多个字段需要具备唯一性的问题，唯一键的本质与主键差不多，唯一键默认允许字段为空，而且可以多个字段为空，因此，空字段不参与唯一性的比较。当唯一键满足非空条件的时候，其性质跟主键是一样的。

唯一键与主键的区别：唯一键允许字段值为空，并且允许多个空值存在

## 3. 索引

索引：系统根据某种算法，将已有的数据(未来可能新增的数据),单独建立一个文件，这个文件能够实现快速匹配数据，并且能够快速的找到对应的记录，几乎所有的索引都是建立在字段之上的。

索引的意义：

- 提升查询数据的效率
- 约束数据的有效性

增加索引的条件：

- 如果某个字段需要作为查询的条件经常使用，可以使用索引
- 如果某个字段需要进行数据的有效性约束，也可以使用索引(主键和唯一键)

索引的分类：

- 主键索引 (primary key)
- 唯一键索引 (unique key)
- 普通索引 (index)
- 全文索引 (fulltext index)

> 全文索引即根据文章内部的关键词进行索引，其最大的难度在于如何确定关键词

## 4. 范式

范式：Normal farmat ,是为了解决数据的存储和优化问题

在数据存储之后，范式能够通过关系寻找出来的数据，坚决不再重复存储，范式的终极目标是减少数据冗余

范式是一种分层结构的规范，共6层，分别为1NF、2NF、3NF、4NF、5NF、6NF，每一层都比上一层严格，若要满足下一层范式，其前提是先满足上一层范式。其中1NF是最底层的范式。6NF是最高层的范式，也最严格

MySQL数据属于关系型数据库，其存储数据的时候有些浪费空间，但也致力于节省空间，这就与范式想要解决的问题不谋而合，因此在设计数据库的时候，大都会利用范式来知道设计。但是数据库不单是要解决存储空间的问题，还要保证效率的问题，而范式只为解决存储空间的问题，所以数据库的设计又不能完全按照范式的要求来实现，因此在一般情况下，只需要满足前三种范式即可

1. 1NF

第一范式：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前还需要额外的处理(拆分)，那么表的设计就不满足第一范式，第一范式要求字段的数据具有原子性，不再可分

例如：

id | 学校名称 | 起始时间，结束时间
-|-|-
1 | 哈尔滨工业大学 | 20170625,20170903
2 | 浙江大学 | 20170630,20170901

观察上表，咱们会发现表1的设计并没有什么问题，但是如果需求是查询各学校开始放假的日期呢？那显然上表的设计不满足1NF,数据不具有原子性。

拆分后的表

id | 学校名称 | 起始时间 | 结束时间
-|-|-|-
1 | 哈尔滨工业大学 | 20170625 | 20170903
2 | 浙江大学 | 20170630 | 20170901

2. 2NF

第二范式：在数据表的设计过程中，如果有复合主键(多字段主键),切表中有字段并不是由整个主键来确定，而是依赖复合主键中的某个字段(主键的部分),也就是说存在字段依赖主键的部分的问题(称之为部分依赖),第二范式就是解决表设计中不允许出现部分依赖

例如，设计一个教室授课表

教师 | 性别 | 课程 | 授课地点
-|-|-|-
许仙 | 男 | <<如何追到心爱的女生>> | 杭州西湖
白娘子 | 女 | <<论女人的恋爱修养>> | 雷峰塔
白娘子 | 女 | <<如何打赢持久战>> | 金山寺

观察上表，教师不能作为独立的主键，需要与授课的地点相结合才能作为主键(复合主键，每个教师的某个课程只能在固定的地点上)，其中性别依赖于具体的老师，而课程依赖于授课地点，这就出现了表的字段依赖于部分的主键的问题，从而导致不满足第二范式

解决方案1：将教师和性别，课程和授课地点，分成两张表
解决方案2：取消复合主键，使用逻辑主键

在此，我们采用方案2

id | 教师 | 性别 | 课程 | 授课地点
-|-|-|-|-
1 | 许仙 | 男 | <<如何追到心爱的女生>> | 杭州西湖
2 | 白娘子 | 女 | <<论女人的恋爱修养>> | 雷峰塔
3 | 白娘子 | 女 | <<如何打赢持久战>> | 金山寺

3. 3NF
第三范式：需要满足第一范式和第二范式，理论上讲，每张表中的所有字段都应该直接依赖主键(逻辑主键，代表是业务主键)，如何表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现主键依赖(把这种不是直接依赖主键，而是依赖非主键字段的依赖关系，称之为传递依赖)，第三范式主要解决的是表设计中出现的传递依赖的问题

id | 教师 | 性别 | 课程 | 授课地点
-|-|-|-|-
1 | 许仙 | 男 | <<如何追到心爱的女生>> | 杭州西湖
2 | 白娘子 | 女 | <<论女人的恋爱修养>> | 雷峰塔
3 | 白娘子 | 女 | <<如何打赢持久战>> | 金山寺

在以上表的设计中，性别依赖于教师，教师依赖于主键，课程依赖授课地点，授课地点依赖主键，因此性别和课程都存在传递依赖得问题

解决方案：将存在传递依赖的字段以及依赖的字段本身单独取出来，形成一个单独的表，然后在需要使用对应信息的时候，把对应的实体表的主键添加进来

id | 教师 | 性别 |
-|-|-
1 | 许仙 | 男 |
2 | 白娘子 | 女 |
3 | 白娘子 | 女 |


address_id | 课程 | 授课地点
-|-|-
1 | 许仙 | <<如何追到心爱的女孩>> | 杭州西湖 
2 | 白娘子 | <<论女人的恋爱修养>> | 雷峰塔
3 | 白娘子 | <<如何打赢持久战>> | 金山寺



id | Teacher_id | Address_id |
-|-|-
1 | 1 | 1 |
2 | 2 | 2 |
3 | 3 | 3 |


总结：

1NF：字段不可分
2NF:有主键，非主键字段依赖主键
3NF:非主键字段不能相互依赖

解释：
1NF：原子性，字段不可再分，否则就不是关系型数据库
2NF：唯一性，一个表只说明一个事物，表中的每一列的字段你都和主键相关
3NF:每列都与主键有直接关系，不存在依赖传递，更进一步


## 5.连接查询

连接查询：将多张表(大于等于2张表)按照某个指定的条件进行数据的拼接，其最终结果记录数可能有变化，但字段数一定会增加

连接查询的意义：在用户查询数据的时候，需要显示的数据来自于多张表

1. 内连接
2. 外连接
3. 自然连接
4. 交叉连接

### 交叉连接
交叉连接：cross join，从一张表中循环取出每一条记录，每条记录都去另外一张表进行匹配，匹配的结果都保留，而连接本身的字段会增加，最终形成的结果为笛卡尔积形式

其结果与多表查询相同

    select * from student cross join class;
    select * from student,class;

实际上，这种查询方式没有意义感觉

### 内连接

内连接:inner join ，从坐标中取出每一条记录，和右表中的所有记录进行匹配，并且仅当某个条件在左表则不保留。和右表中的值相同的时候，结果才保留。

基本语法: 左表 + inner join + 右表 + on + 左表.字段 = 右表.字段

    select * from student inner join class on student.grade = class.grade;
    select * from student join class on student.grade = class.grade;

最后，内连接可以没有连接条件，即可以没有on后面的内容，这时候内连接的结果全部保留，与交叉连接结果相同。而且在内连接的时候可以用where关键字替代on ,但where没有on的效率高

### 外连接

外连接:left/right join 以某张表为主表，取出里面的所有记录，然后让主表中的每条记录都与另外一张表进行连接，不管是否匹配成功，其最终的结果都会保留，匹配成功，则正确保留，匹配失败，则将另一张表的字段都设置为NULL

基本语法：左表 + left/right join + 右表 + on + 左表.字段 = 右表.字段

left join:左外连接，以左表为主表
right join:右外连接，以右表为主表

### 自然连接

自然连接：nature join ，自然连接其实就是自动匹配连接条件，系统以两表中同名字段作为匹配的条件，如果两表有多个同名字段，那就都作为匹配条件，自然连接分为自然外连接和自然内连接

自然内连接基本语法：左表 + nature join + 右表
自然外连接基本语法：左表 + nature left/right join + 右表

## 6.外键

外键：foregin key，外面的键，即不在自己表中的键。如果一张表中有一个非主键的字段指向另外一张表的主键，那么该字段就称之为外键，每张表中，可以有多个外键

外键的默认作用有两个：分别对子表和父表进行约束

1. 约束子表,在子表(有外键的表)进行数据写操作的时候(增和改),如果对应的外键字段在父表(外键指向的表)找不到对应的匹配，那么操作失败

2. 约束父表：在父表进行数据的写操作(删和改)的时候，如果对应的主键字段在字表中已经被数据引用了，则操作失败

举例一个订单的表，里面放着某个产品的订单信息，当你修改或者删除该订单的时候，如果该订单的产品不在产品的表中，会出现错误。反之，当你把产品的信息删除或者修改了，同样也会影响订单的表，所以这时候就需要进行外键的约束了

## 7. 联合查询

联合查询：union，将多次查询的结果，在字段数量相同的情况下，在记录的层次上进行拼接

基本语法：select 语句1 + union + 选项 + select 语句2 + ....

union选项:
- all，无论重复与否，保留所有的选项
- distinct:表示去重，为默认选项

举例:

    //联合查询，默认去重    
    select * from class union distinct select * from class;
    //联合查询，保留所有的记录
    select * from class union all selct * from class;


联合查询的意义：

- 查询同一张表，按时需要不同，例如查询学生信息，要求男生按年龄升序排序，女生按年龄降序排序

- 多表查询，多张表的结构是完全一样的，保持的数据结构有是一样的。此外，如果数据量非常的大，就要进行分表(垂直分表和水平分表)

> 注意，联合查询的时候注意加()和加limit

## 7. 子查询

子查询：sub query,查询是在某个查询结果之上进行的，一条select语句内部包含了另外一条select语句

子查询分为两种类型：

- 按结果分类
    - 标量子查询:子查询得到的结果是一行一列，出现的位置在where之后
    - 列子查询：子查询得到的结果是一列多行，出现的位置在where之后
    - 行子查询:子查询得到的结果是多行一列(多行多列),出现的位置在where之后
    - 表子查询：子查询得到的结果是多行多列,出现的位置在from之后
- 按位置分类
    - from子查询:子查询出现在from之后
    - where子查询：子查询出现在where条件之中
    - exists子查询：子查询出现在exists里面

## 8. 视图

视图：view,是一种有结构(有行有列),但没有结果(结构中不真实存放数据)的虚拟表。虚拟表的结构原来不是自己定义的，而是从对应的基表(视图的数据来源)中产生的

基本语法：create view + 视图名 + as + select语句

其中，select语句可以是普通查询，也可以是连接查询、联合查询、子查询等

此外，视图根据数据的来源，可以分为单表视图和多表视图

视图的主要作用：视图可以节省sql语句，将一条复杂的查询语句用视图来进行封装，以后可以直接对视图进行操作

数据安全，视图操作主要针对查询的，如果对视图结构进行处理，并不会影响基表的数据

视图往往会用在大型项目中，而且是多系统中，可以对外提供有用的数据，但是隐藏关键的数据

## 9. 事务

案例：银行的数据库里面存储着用户的账户信息表，当用户 A 想用户 B 转账的时候，正常情况下，A 账户的余额减少，B 账户的余额增加；但是由于某种原因（例如突然断电），当 A 账户的余额减少之后，B 账户的余额并没有增加，这就造成了数据库数据的安全隐患。

解决方案：当 A 账户的余额减少之后，不要立即修改数据表，而是在确认 B 账户的余额增加之后，同时修改数据表。

通过前面的案例及解决方案，我们就引出了一个全新的概念，那就是：事务，即
一系列将要发生或正在发生的连续操作。

而事务安全，是一种保护连续操作同时实现（完成）的机制。事务安全的意义就是，保证数据操作的完整性。

1. 第一步，开启事务,start transaction
2. 第二步,减少A账户的余额
3. 第三步,增加B账户的余额
4. 第四步,提交事务或回滚事务,提交commit 回滚rollback,如果我们选择提交事务，则将事务日志存储的记录直接更新到数据库，并清除事务日志。如果我们选择回滚事务，则直接将事务日志清除，所有在开启事务至回滚事务之间的操作失效，保持原有的数据库记录不变

事务的原理：在事务开之后，所有的操作都会被临时存储到事务的日志，事务日志只有在收到commit命令之后，才会将操作同步到数据表，其他任何情况下都会清空事务日志，例如突然断开了连接、收到了rollback命令了

我们来分析一下MySQL的操作过程：

1. 客户端与服务器端建立连接，同时开启一个临时的事务日志，此事务日志当前用户的当次连接
2. 在客户端用sql语句执行写操作，客户端收到sql语句，执行，将结果直接写入数据表，并将数据表同步到数据库
3. 我们在客户端开启事务，则服务器端原来的操作机制被改变，后续所有的操作都会被先写到临时的日志文件
4. 在客户端执行sql语句的时候，服务器接收到sql语句，执行，将结果写入到临时的日志文件，并不将结果同步到数据库
5. 在客户端执行查询操作，服务端直接从临时日志文件中捞取数据，返回给客户端
6. 在客户端执行commit或者rollback命令，清空临时日志文件，如果是commit命令，则将结果同步到数据库，如果是rollback命令，则不同步

通过上面的分析，我们就知道了为什么在我们同时开启两个 MySQL 客户端窗口（两次连接）时，当一个窗口开启事务并执行 SQL 操作之后，另一个窗口在查询时并不会收到同步数据。原因就在于，当我们开启事务之后，服务端会将后续的操作都写入到临时日志文件，而另一个窗口在查询的时候，则是直接从数据库捞取数据，并会不走前一个的临时日志文件。

事务的特性，可以简单的概括为ACID，具体为：

- 原子性：Atomic，表示事务的整个操作是一个整体，是不可分割的，要么全部成功，要么全部失败；
- 一致性：Consistency，表示事务操作的前后，数据表中的数据处于一致状态；
- 隔离性：Isolation，表示不同的事务操作之间是相互隔离的，互不影响；
- 持久性：Durability，表示事务一旦提交，将不可修改，永久性的改变数据表中的数据。

## 10. 触发器

网上购物，根据生产订单的类型，商品的库存量对应的进行增和减。此案例涉及到两张表，分别为订单表和商品表。下单时候，商品表的库存减少，退单时候，商品表库存增加，如何实现？

触发器:trigger,是指事先为某张表绑定一段代码，当表中的某些内容发生改变(增、删、该)的时候，系统会自动触发代码执行

触发器包含三个要素:
事件类型:增删改，即insert/delete/update
触发时间：事件类型前和后，即before和after
触发对象：表中的每一条记录，即整张表

每张表只能拥有一种触发时间的一种事件类型的触发器，即每张表最多可以拥有6种触发器

delimiter 自定义符号 -- 临时修改语句结束符，在后续语句中只有遇到自定义符号才会结束语句

create trigger + 触发器名称 + 触发器时间 + 事件类型 on 表名 for each row

begin -- 代表触发器内容开始

-- 触发器内容主体，每行用分号结尾

end -- 代表触发器内容结束

自定义符号 -- 用于结束语句

delimiter ; -- 恢复语句结束符



## 11. 存储过程

存储过程简称过程,procedure,是一种用来处理数据(增删改)的方式。简单点，我们可以理解为没有返回值的函数

create procedure 过程名([参数列表])

begin 

    ---过程体
end    



# mysql优化知识

## 1. mysql对千万级别的大表如何优化

很多人第一反应是各种切分；我给的顺序是:

第一在表、字段设计阶段，考虑更优的存储和运算

第二在数据库本身提供的优化手段上---索引

第三加缓存，这里你可使用应用层的缓存memcached,redis，也可以使用SQL中的自带的缓存功能

第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具

第四如果以上都做了还是慢，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区

第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统

第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表

mysql数据库一般都是按照这个步骤去演化的，成本也是由低到高

最后，我们还可以优化自己的sql语句，通过profile和慢查询日志找到慢的点针对性的优化，同时也可以通过mysqlslap进行压力测试

下面，我们分别来针对这几个点做一些说明：

### 




























